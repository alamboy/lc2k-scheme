#lang racket

(require "driver.rkt")
(require "compiler.rkt")

(define (for-racket-eval code)
  (if (and (list? code) (list? (car code)))
      (cons 'begin code)
      code))

(define (test-case code (expect #f))
  (let* ([expected (or expect (eval (for-racket-eval code)))]
         [result (compile-ret code)])
    (unless (equal? result expected)
      (raise-arguments-error 'test-case
                             "Obtained wrong result"
                             "code"     code
                             "expected" expected
                             "result"   result))))

(define (run-tests)
  (let ([section #f])
    (define (test-section s)
      (displayln (format "Section: ~a" s))
      (set! section s))
    (test-section "Constant loading and returning")
    (test-case '58 58)
    (test-case '0 0)
    (test-section "Non-numeric constants")
    (test-case #t #t)
    (test-case #f #f)
    (test-case #\a #\a)
    (test-case #\Z #\Z)
    (test-case empty empty)
    (test-section "Unary primitives")
    ;;(test-case '(zero? 0))
    ;;(test-case '(zero? 9))
    (test-case '(- 9) -9)
    (test-case '(- -9) 9)
    (test-case '(bitwise-not 1))
    (test-section "Binary primitives")
    (test-case '(+ 3 5) 8)
    (test-case '(+ (+ 3 5) 4) 12)
    (test-case '(- 1 9))
    (test-case '(- 1 (+ 3 9)))
    (test-case '(bitwise-ior 6 1))
    (test-case '(bitwise-and 17 1))
    (test-section "Predicates")
    (test-case '(zero? 9))
    (test-case '(zero? 0))
    (test-case '(integer? 0))
    (test-case '(integer? #\a))
    (test-case '(number? 0))
    (test-case '(number? #\a))
    (test-case '(boolean? #t))
    (test-case '(boolean? #f))
    (test-case '(boolean? 3))
    (test-case '(boolean? empty))
    (test-case '(char? #\y))
    (test-case '(char? 9))
    (test-case '(char? #t))
    (test-case '(eq? 1 1))
    (test-case '(eq? 1 3))
    (test-case '(eq? (cons 1 empty) (cons 1 empty)))
    (test-case '(empty? 3))
    (test-case '(empty? empty))
    (test-case '(empty? (cons 1 empty)))
    (test-case '(null? 3))
    (test-case '(null? empty))
    (test-case '(null? (cons 1 empty)))
    (test-case '(pair? empty))
    (test-case '(pair? 1))
    (test-case '(pair? (cons 1 3)))
    (test-section "Numerical operations")
    (test-case '(negative? 256))
    (test-case '(negative? 1))
    (test-case '(negative? 0))
    (test-case '(negative? -1))
    (test-case '(negative? -256))
    (test-case '(positive? 256))
    (test-case '(positive? 1))
    (test-case '(positive? 0))
    (test-case '(positive? -1))
    (test-case '(positive? -256))
    (test-case '(odd? -1))
    (test-case '(odd? 2))
    (test-case '(odd? 0))
    (test-case '(odd? 1))
    (test-case '(even? -1))
    (test-case '(even? 2))
    (test-case '(even? 0))
    (test-case '(even? 1))
    (test-section "Lambdas")
    ;;(test-case '((lambda (n) (+ 5 n)) 9) (+ 5 9))
    (test-section "Simple conditionals")
    (test-case '(if (empty? empty) 1 99))
    (test-case '(+ (if (empty? empty) 1 99)
                   (+ (if (zero? 1) 2000 20)
                      373)))
    (test-section "Complex conditionals")
    (test-case '(if (or (zero? 5) (and (zero? 0) (= 5 5))) 1 0))
    (test-case '(if (not (zero? 7)) 100 2))
    (test-section "Conses")
    ;;(test-case '(empty? empty) #t)
    (test-section "Functions")
    (test-case '((define (foo) 5) (+ 1 (foo))) 6)
    (test-case '((define (foo n) (+ 5 n)) (+ 1 (foo 7))) 13)
    (test-case
     '(
       (define (sum l acc)
         (if (empty? l)
             acc
             (sum (cdr l)
                  (+ (car l) acc))))
       (sum (cons 1 (cons 2 (cons 3 (cons 4 (cons 5 empty)))))
            0)
       )
     15)
    (test-section "First-class procedures")
    (test-case
     '(
       (define (use f)
         ;; not in tail position
         (+ (f 1 2) 9))
       (use +)))
    (displayln "All tests succeeded.")))
